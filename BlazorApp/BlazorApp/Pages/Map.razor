@page "/Map"
@using BlazorApp.Controller.Enums;
@using BlazorApp.Controller.Factory;
@using BlazorApp.Controller.Ships;

@inject Identification identification
@inject NavigationManager NavManager

Etat connexion : @identification.Connected
@{
    if (identification.Connected)
    {
        <button class="btn btn-primary" @onclick="Reset">Reset me</button>
        <p>Difficulty chose : @Utility.DescriptionAttr(Diff)</p>
        <button class="btn btn-primary" @onclick="SetDifficultyEasy">smol pp</button>
        <button class="btn btn-primary" @onclick="SetDifficultyMedium">Difficulty Medium</button>
        <style>
            div{
                font-size: 0.8em;
            }
        </style>
        if (s != null)
        {
            <div>
                @s.Name;
                @s.GetType().ToString();
                @s.TopLeft.X;
                @s.TopLeft.Y;
                @s.OrientationType
            </div>
        }
        <p>@Placed.Count placed</p>
        if (Placed.Count == 6)
        {
            <button class="btn btn-primary" id="aa" @onclick="Validate">Validate</button>
        }
        @message
        <div>
            <button class="btn btn-primary" id="aa" @onclick="Spawn">Click me</button>
            <button class="btn btn-primary" @onclick="Right">🡢</button>
            <button class="btn btn-primary" @onclick="Bottom">🡣</button>
            <button class="btn btn-primary" @onclick="Left">🡠</button>
            <button class="btn btn-primary" @onclick="Top">🡡</button>
            <br>
            <button class="btn btn-primary" @onclick="Rotate">Next Rotate</button>
            <button class="btn btn-primary" @onclick="VerticalRotate">Vertical Rotate</button>
            <button class="btn btn-primary" @onclick="HorizonthalRotate">Horizonthal Rotate</button>
            <button class="btn btn-primary" @onclick="DiagBRRotate">Diag BR Rotate</button>
            <button class="btn btn-primary" @onclick="DiagTRRotate">Diag TR Rotate</button>

        </div>
        <div>
            <button class="btn btn-primary" @onclick="Destroyer">Destroyer</button>
            <button class="btn btn-primary" @onclick="Cruiser">Cruiser</button>
            <button class="btn btn-primary" @onclick="Submarine">Submarine</button>
            <button class="btn btn-primary" @onclick="Battleship">Battleship</button>
            <button class="btn btn-primary" @onclick="Carrier">Carrier</button>
            <button class="btn btn-primary" @onclick="Titanic">Titanic</button>
        </div>
        @((MarkupString)@Draw())
    }
}


@code{
    public Ship s { get; set; }
    public static Player p = PlayerFactory.Player();
    public string message = "";
    public List<Ship> Placed = new List<Ship>();
    public GameBoard gb { get; set; } = p.GameBoard;
    public Difficulties Diff { get; set; } = Difficulties.FACILE;

    public void VerticalRotate()
    {
        if (s == null) return;
        Orientation save = s.OrientationType;
        if (!gb.Rotate(s,Orientation.VERTICAL))
        {
            message = "Rotate not permitted";
            s.GenerateTiles();
            s.GenerateNear();
        }
        else
        {
            Spawn();
        }
    }

    public void HorizonthalRotate()
    {
        if (s == null) return;
        Orientation save = s.OrientationType;
        if (!gb.Rotate(s,Orientation.HORIZONTHAL))
        {
            message = "Rotate not permitted";
            s.GenerateTiles();
            s.GenerateNear();
        }
        else
        {
            Spawn();
        }
    }

    public void DiagBRRotate()
    {
        if (s == null) return;
        Orientation save = s.OrientationType;
        if (!gb.Rotate(s,Orientation.DIAG_BR))
        {
            message = "Rotate not permitted";
            s.GenerateTiles();
            s.GenerateNear();
        }
        else
        {
            Spawn();
        }
    }

    public void DiagTRRotate()
    {
        if (s == null) return;
        Orientation save = s.OrientationType;
        if (!gb.Rotate(s,Orientation.DIAG_TR))
        {
            message = "Rotate not permitted";
            s.GenerateTiles();
            s.GenerateNear();
        }
        else
        {
            Spawn();
        }
    }

    public void SetDifficultyEasy()
    {
        Diff = Difficulties.FACILE;
    }

    public void SetDifficultyMedium()
    {
        Diff = Difficulties.MOYEN;
    }

    public void Validate()
    {
        p.Ships = Placed;
        identification.Player = p;
        identification.Player.FiringBoard = identification.Ia.GameBoard;
        identification.Ia.FiringBoard = identification.Player.GameBoard;
        identification.Game.Player = p;
        identification.Game.Difficuty = Diff;
        identification.Difficulty = Diff;
        NavManager.NavigateTo("/Game");
    }

    public void Reset()
    {
        p.GameBoard.GenerateTiles();
        Placed = new List<Ship>();
        gb = p.GameBoard;
        identification.Ia = new IA();
        p.GenerateShips();
        Draw();
    }

    #region Movements
    public void Move(string dir)
    {
        if(s == null)
        {
            return;
        }
        if (dir != "spawn")
        {
            if (!Placed.Contains(s))
            {
                message = "Boat not placed !";
                return;
            }
        }
        bool ok = false;
        GameBoard tempGB = (GameBoard)gb.Clone();
        Ship tempShip = (Ship)s.Clone();
        if (dir == "spawn")
        {
            if (Placed.Contains(s))
            {
                gb.Remove(s);
                gb.Add(s);
                return;
            }
            if (!tempGB.IsAddable(tempShip))
            {
                message = dir + " not allowed !";
                return;
            }
        }
        tempGB.Remove(tempShip);
        tempShip = tempShip.Direction(dir);
        gb.Remove(s);
        Placed.Remove(s);
        if (tempGB.IsAddable(tempShip))
        {
            s = s.Direction(dir);
            ok = true;
        }
        else
        {
            message = dir + " not allowed !";
        }
        if (dir == "spawn" && !ok)
        {
            DrawWithPlaced();
            return;
        }
        Placed.Add(s);
        gb.Add(s);
        DrawWithPlaced();
    }

    public void Right(){ Move("right"); }
    public void Top(){ Move("top"); }
    public void Bottom(){ Move("bottom"); }
    public void Left(){ Move("left"); }

    public void Rotate()
    {
        if (s == null) return;
        Orientation save = s.OrientationType;
        if (!gb.Rotate(s))
        {
            message = "Rotate not permitted";
            s.GenerateTiles();
        }
        else
        {
            Spawn();
        }
    }
    #endregion Movements

    #region Drawings
    public void DrawWithPlaced()
    {
        foreach (Ship s in Placed)
        {
            foreach (Tile t in s.Near)
            {
                if (Utility.Contains(t, gb.Tiles))
                {
                    Tile tt = gb.Tiles[Utility.Index(t, gb.Tiles)];
                    tt.OccupationType = t.OccupationType;
                }
            }
            foreach (Tile t in s.Tiles)
            {
                if (Utility.Contains(t, gb.Tiles))
                {
                    Tile tt = gb.Tiles[Utility.Index(t, gb.Tiles)];
                    tt.OccupationType = t.OccupationType;
                }
            }

        }
    }

    public string Draw()
    {
        string temp = "<div class=\"container\" style=\"width: 800px\">";
        int index = 0;
        for(int h = 0; h < gb.Height; h++)
        {
            temp += "<div class=\"row\">";
            for(int w = 0; w < gb.Width; w++)
            {
                index = w * gb.Width + h;
                string color = "background-color: red;";
                if(gb.Tiles[index].OccupationType == Occupation.Empty)
                {
                    color = "background-color: red;";
                }
                else
                {
                    if (gb.Tiles[index].OccupationType == Occupation.Near)
                    {
                        color = "background-color: blue;";
                    }
                    else
                    {
                        color = "background-color: green;";
                    }
                }
                Tile t = gb.Tiles[index];
                temp += $"<div class=\"col\" style=\"{color}justify-content: center;display: flex;border: 1px solid;height:25px\">{t.X}/{t.Y}</div>";
            }
            temp += "</div>";
        }
        temp += "</div>";
        return temp;
    }
    #endregion Drawings

    #region Spawners
    public void Spawn()
    {
        if (s == null) return;
        Move("spawn");
        s.GenerateTiles();
        s.GenerateNear();
    }

    public void Destroyer()
    {
        s = Get("BlazorApp.Controller.Ships.Destroyer");
        Spawn();
    }

    public void Cruiser()
    {
        s = Get("BlazorApp.Controller.Ships.Cruiser");
        Spawn();
    }

    public void Submarine()
    {
        s = Get("BlazorApp.Controller.Ships.Submarine");
        Spawn();
    }

    public void Battleship()
    {
        s = Get("BlazorApp.Controller.Ships.Battleship");
        Spawn();
    }

    public void Carrier()
    {
        s = Get("BlazorApp.Controller.Ships.Carrier");
        Spawn();
    }

    public void Titanic()
    {
        s = Get("BlazorApp.Controller.Ships.Titanic");
        Spawn();
    }

    public Ship Get(string type)
    {
        foreach (Ship ship in p.Ships)
        {
            if (ship.GetType().ToString() == type)
            {
                return ship;
            } 
        }
        return null;
    }
    #endregion Spawners
}